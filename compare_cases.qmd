---
title: "Compare MIP cases"
format: dashboard
# jupyter: python3
server: shiny
---

```{python}
# | context: setup
from typing import Any, Dict, List
from shiny.express import ui, render
from shinywidgets import render_altair
from shiny import reactive
import pandas as pd

import geopandas as gpd
import numpy as np
from pathlib import Path
import altair as alt

import anywidget
import fastparquet
import pyodide_http

pyodide_http.patch_all()


_COLOR_MAP = {
    "Battery": "#4379AB",
    "CCS": "#96CCEB",
    "Coal": "#FF8900",
    "Distributed Solar": "#FFBC71",
    "Geothermal": "#3DA443",
    "Hydro": "#76D472",
    "Hydrogen": "#BA9900",
    "Natural Gas CC": "#F7CD4B",
    "Natural Gas CT": "#249A95",
    "Nuclear": "#77BEB6",
    "Solar": "#F14A54",
    "Wind": "#FF9797",
}

TECH_ORDER = [
    "Nuclear",
    "CCS",
    "Natural Gas CC",
    "Natural Gas CT",
    "Coal",
    "Geothermal",
    "Hydro",
    "Distributed Solar",
    "Solar",
    "Wind",
    "Hydrogen",
    "Battery",
]

COLOR_MAP = {k: _COLOR_MAP[k] for k in TECH_ORDER[::-1]}

TECH_STACK_ORDER = {v: i for i, v in enumerate(TECH_ORDER)}

MODEL_ORDER = ["GenX", "SWITCH", "TEMOA", "USENSYS"]

VAR_ABBR_MAP = {
    "model": "m",
    "case": "c",
    "planning_year": "y",
    "resource_name": "rn",
    "agg_zone": "az",
    "zone": "z",
    "tech_type": "tt",
    "value": "v",
    "end_value": "ev",
    "line_name": "ln",
    "Region": "r",
}

region_map = {
    "WECC": ["BASN", "NWPP", "SRSG", "RMRG"],
    "CA": ["CANO", "CASO"],
    "TRE": ["TRE", "TREW"],
    "SPP": ["SPPC", "SPPN", "SPPS"],
    "MISO": ["MISC", "MISE", "MISS", "MISW", "SRCE"],
    "PJM": ["PJMC", "PJMW", "PJME", "PJMD"],
    "SOU": ["SRSE", "SRCA", "FRCC"],
    "NE": ["ISNE", "NYUP", "NYCW"],
}


def reverse_dict_of_lists(d: Dict[str, list]) -> Dict[str, List[str]]:
    """Reverse the mapping in a dictionary of lists so each list item maps to the key

    Parameters
    ----------
    d : Dict[str, List[str]]
        A dictionary with string keys and lists of strings.

    Returns
    -------
    Dict[str, str]
        A reverse mapped dictionary where the item of each list becomes a key and the
        original keys are mapped as values.
    """
    if isinstance(d, dict):
        rev = {v: k for k in d for v in d[k]}
    else:
        rev = dict()
    return rev


rev_region_map = reverse_dict_of_lists(region_map)


def title_case(s: str) -> str:
    if isinstance(s, str):
        return s.replace("_", " ").title()


cap = pd.read_parquet(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/capacity.parquet"
)
gen = pd.read_parquet(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/generation.parquet"
)
emiss = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/emissions.csv"
)
tx_exp = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/annual_tx_expansion.csv"
)
op_costs = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/operational_costs.csv"
)
op_costs_model = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/operational_costs_model.csv"
)
op_nse = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/compiled_results/all/operational_nse.csv"
)
gdf = gpd.read_file(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/notebooks/conus_26z_latlon_simple.geojson"
)
gdf = gdf.rename(columns={"model_region": "zone"})
gdf["lat"] = gdf.geometry.centroid.y
gdf["lon"] = gdf.geometry.centroid.x

annual_demand = pd.read_csv(
    "https://raw.githubusercontent.com/gschivley/MIP_results_comparison/main/notebooks/annual_demand.csv"
)
annual_demand.loc[:, "agg_zone"] = annual_demand.loc[:, "zone"].map(rev_region_map)

base_case_list = [
    "full-base-200",
    "full-base-200-retire",
    "full-base-200-no-ccs",
    "full-base-200-commit",
    "full-base-50",
    "full-base-1000",
    "full-base-200-tx-0",
    "full-base-200-tx-15",
    "full-base-200-tx-50",
    "20-week-foresight",
    "20-week-myopic",
]
cp_case_list = [
    "full-current-policies",
    "full-current-policies-retire",
    "full-current-policies-commit",
    "20-week-foresight-current-policy",
    "20-week-myopic-current-policy",
]
all_models = ["GenX", "SWITCH", "TEMOA", "USENSYS"]
all_years = [2027, 2030, 2035, 2040, 2045, 2050]
```
# {.sidebar}
```{python}


ui.input_selectize(
    "base_cases",
    "Base cases",
    base_case_list,
    selected=["full-base-200"],
    multiple=True,
    remove_button=True,
)
ui.input_selectize(
    "cp_cases",
    "Current policy cases",
    cp_case_list,
    selected=["full-current-policies"],
    multiple=True,
    remove_button=True,
)
ui.input_selectize("models", "Models", all_models, selected=all_models, multiple=True)
ui.input_selectize(
    "year", "Model years", choices=all_years, selected=all_years, multiple=True
)
# ui.input_radio_buttons(
#     "mark_type",
#     "Plot type",
#     {"bar": "Bar Chart", "line": "Line Chart"},
#     inline=True,
#     width="400px",
# )


# @reactive.effect
# def _():
#     ui.input_selectize(
#         id="case_order",
#         label="Case order",
#         choices=list(input.base_cases()) + list(input.cp_cases()),
#         selected=list(input.base_cases()) + list(input.cp_cases()),
#         multiple=True,
#     )


ui.input_selectize("mark_type", "Plot Type", choices=["Bar", "Line"], selected="Bar")

```
```{python}
# | output: false
# alt.data_transformers.enable("vegafusion")
alt.data_transformers.disable_max_rows()
```
```{python}
@reactive.calc
def case_list():
    return [c for c in input.base_cases()] + [c for c in input.cp_cases()]


@reactive.calc
def cap_cases():
    df = cap.loc[
        (cap["case"].isin(case_list()))
        & (cap["planning_year"].isin([int(y) for y in input.year()]))
        & (cap["model"].isin(input.models())),
        :,
    ]
    return df


@reactive.calc
def gen_cases():
    df = gen.loc[
        (gen["case"].isin(case_list()))
        & (gen["planning_year"].isin([int(y) for y in input.year()]))
        & (gen["model"].isin(input.models())),
        :,
    ]
    # if input.cap_filter() == "new":
    #     df = df.loc[df["new_build"] == True, :]
    # elif input.cap_filter() == "existing":
    #     df = df.loc[df["new_build"] == False, :]
    return df


@reactive.calc
def emiss_cases():
    return emiss.loc[
        (emiss["case"].isin(case_list()))
        & (emiss["planning_year"].isin([int(y) for y in input.year()]))
        & (emiss["model"].isin(input.models())),
        :,
    ]


@reactive.calc
def tx_exp_cases():
    return tx_exp.loc[
        (tx_exp["case"].isin(case_list()))
        & (tx_exp["planning_year"].isin([int(y) for y in input.year()]))
        & (tx_exp["model"].isin(input.models())),
        :,
    ]


@reactive.calc
def op_costs_model_data():
    df = op_costs_model.copy()
    return df.loc[
        (df["case"].isin(case_list()))
        & ((df["planning_year"].isin(input.year())) | (df["planning_year"] == "NPV"))
        & (df["model"].isin(input.models())),
        :,
    ]


@reactive.calc
def op_costs_data():
    df = op_costs.copy()
    return df.loc[
        (df["case"].isin(case_list()))
        & ((df["planning_year"].isin(input.year())) | (df["planning_year"] == "NPV"))
        & (df["model"].isin(input.models())),
        :,
    ]


@reactive.calc
def op_nse_data():
    df = op_nse.copy()
    return df.loc[
        (df["case"].isin(case_list()))
        & (df["planning_year"].isin([int(y) for y in input.year()]))
        & (df["model"].isin(input.models())),
        :,
    ]


@reactive.calc
def order_dict():
    return {
        "case": list(input.base_cases()) + list(input.cp_cases()),
        "model": list(input.models()),
        "planning_year": [int(y) for y in input.year()],
    }


def filter_data(df: pd.DataFrame) -> pd.DataFrame:
    _df = df.copy()
    if "case" in df.columns:
        _df = _df.loc[_df["case"].isin(case_list()), :]
    if "planning_year" in df.columns:
        _df = _df.loc[_df["planning_year"].isin([int(y) for y in input.year()]), :]
    if "model" in df.columns:
        _df = _df.loc[_df["model"].isin(input.models()), :]
    if "new_build" in df.columns:
        if input.cap_filter() == "new":
            _df = _df.loc[_df["new_build"] == True, :]
        elif input.cap_filter() == "existing":
            _df = _df.loc[_df["new_build"] == False, :]
    return _df
```

# Capacity and Gen by model
## Row

#### Column {.tabset}
```{python}
# | content: card-toolbar
ui.input_selectize(
    "cap_filter",
    "Build Type",
    choices=["new", "existing", "all"],
    selected="all",
    width="100px",
)

ui.input_selectize(
    "cap_x_var",
    "X Variable",
    choices=["model", "case", "planning_year", "agg_zone"],
    selected="model",
    width="125px",
)
ui.input_selectize(
    "cap_col_var",
    "Column",
    choices=["model", "case", "planning_year", "tech_type", "agg_zone", "None"],
    selected="case",
    width="125px",
)
ui.input_selectize(
    "cap_row_var",
    "Row",
    choices=["model", "case", "planning_year", "tech_type", "agg_zone", "None"],
    selected="planning_year",
    width="150px",
)
ui.input_selectize(
    "cap_color",
    "Color",
    choices=["model", "case", "planning_year", "tech_type", "agg_zone", "None"],
    selected="tech_type",
    width="125px",
)


```

```{python}
# | title: Capacity stacked bar
@render_altair
def alt_cap():
    df = cap_cases()
    if input.cap_filter() == "new":
        df = df.loc[df["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df = df.loc[df["new_build"] == False, :]
    chart = chart_total_cap(
        df,
        # mark_type=input.mark_type(),
        # filter_data(cap),
        x_var=input.cap_x_var(),
        col_var=input.cap_col_var(),
        row_var=input.cap_row_var(),
        color=input.cap_color(),
    )
    return chart

```
```{python}
# | title: Capacity lines
@render_altair
def alt_cap_lines():
    df = cap_cases()
    if input.cap_filter() == "new":
        df = df.loc[df["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df = df.loc[df["new_build"] == False, :]
    chart = chart_total_cap_line(
        df,
        mark_type="line",
        # filter_data(cap),
        x_var="planning_year",
        col_var="tech_type",
        row_var="case",
        color="model",
        width=125,
    )
    return chart

```
```{python}
# | title: Generation
@render_altair
def alt_gen():    
    df_gen = gen_cases()
    if input.cap_filter() == "new":
        df_gen = df_gen.loc[df_gen["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df_gen = df_gen.loc[df_gen["new_build"] == False, :]
    df_cap = cap_cases()
    if input.cap_filter() == "new":
        df_cap = df_cap.loc[df_cap["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df_cap = df_cap.loc[df_cap["new_build"] == False, :]
    chart = chart_total_gen(
        # gen_cases(),
        # cap_cases(),
        df_gen,
        df_cap,
        demand=annual_demand,
        x_var=input.cap_x_var(),
        col_var=input.cap_col_var(),
        row_var=input.cap_row_var(),
    )
    return chart

```
```{python}
# | title: Generation lines
@render_altair
def alt_gen_lines():
    df_gen = gen_cases()
    if input.cap_filter() == "new":
        df_gen = df_gen.loc[df_gen["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df_gen = df_gen.loc[df_gen["new_build"] == False, :]
    df_cap = cap_cases()
    if input.cap_filter() == "new":
        df_cap = df_cap.loc[df_cap["new_build"] == True, :]
    elif input.cap_filter() == "existing":
        df_cap = df_cap.loc[df_cap["new_build"] == False, :]
    chart = chart_total_gen_line(
        df_gen,
        df_cap,
        # mark_type="line",
        # filter_data(cap),
        x_var="planning_year",
        col_var="tech_type",
        row_var="case",
        color="model",
        width=125,
    )
    return chart

```

```{python}
# | title: Capacity data
@render.data_frame
def cap_df():
    return render.DataTable(cap_cases().head(100))

```
```{python}
# | title: Generation data
@render.data_frame
def gen_df():
    return render.DataTable(gen_cases().head(100))

```


# Average Capacity and Gen
## Row

#### Column {.tabset}
```{python}
# | content: card-toolbar
ui.input_selectize(
    "avg_x_var",
    "X Variable",
    choices=["case", "planning_year", "agg_zone", "tech_type", "None"],
    selected="case",
    width="150px",
)
ui.input_selectize(
    "avg_col_var",
    "Column",
    choices=["case", "planning_year", "tech_type", "agg_zone", "None"],
    selected="tech_type",
    width="150px",
)
ui.input_selectize(
    "avg_row_var",
    "Row",
    choices=["case", "planning_year", "tech_type", "agg_zone", "None"],
    selected="agg_zone",
    width="150px",
)
```
```{python}
# | title: Capacity
@render_altair
def alt_avg_cap():
    # region_avg_cap = calc_mean_annual_cap(cap_cases(), by_agg_zone=True)
    chart = chart_avg_new_tech_variation(
        calc_mean_annual_cap(),
        # calc_mean_annual_cap(filter_data(cap), by_agg_zone=True),
        row_var=input.avg_row_var(),  # "agg_zone",
        x_var=input.avg_x_var(),  # "case",
        col_var=input.avg_col_var(),  # "tech_type",
        # order=order,
    )
    return chart
```

```{python}
# | title: Generation
@render_altair
def alt_mean_gen():
    chart = chart_avg_gen_variation(
        # calc_mean_annual_gen(gen_cases(), by_agg_zone=True),
        calc_mean_annual_gen(),
        row_var=input.avg_row_var(),  # "agg_zone",
        x_var=input.avg_x_var(),  # "case",
        col_var=input.avg_col_var(),  # "tech_type",
        # order=order,
    )
    return chart
```
```{python}
# | title: Capacity data
@render.data_frame
def avg_cap_df():
    return render.DataTable(calc_mean_annual_cap().head(100))

```
```{python}
# | title: Generation data
@render.data_frame
def avg_gen_df():
    return render.DataTable(calc_mean_annual_gen().head(100))

```
# Transmission expansion
## Row
#### Column {.tabset}
```{python}
# | content: card-toolbar
ui.input_selectize(
    "tx_x_var",
    "X Variable",
    choices=["case", "model"],
    selected="case",
    width="150px",
)
ui.input_selectize(
    "tx_col_var",
    "Column",
    choices=["case", "model"],
    selected="model",
    width="150px",
)
```
```{python}
# | title: Total expansion
@render_altair
def total_tx_exp():
    chart = chart_tx_expansion(
        tx_exp_cases(),
        x_var=input.tx_x_var(),
        facet_col=None,
        col_var=input.tx_col_var(),
        # order=order
    )
    return chart
```

```{python}
# | title: Average expansion map
@render_altair
def map_avg_tx_exp():
    tx_exp_data = (
        tx_exp_cases()
        .groupby(
            ["line_name", "planning_year", "case", "start_region", "dest_region"],
            as_index=False,
        )["value"]
        .mean()
        .query("value >= 50")
        .sort_values("case")
    )

    chart = chart_tx_map(
        tx_exp_data,
        gdf,
        facet_col="case",
    )
    return chart
```
```{python}
# | title: Tx data
@render.data_frame
def tx_exp_df():
    return render.DataTable(tx_exp_cases().head(100))

```
# Emissions
## Row

```{python}
# | content: card-toolbar
ui.input_selectize(
    "emiss_x_var",
    "X Variable",
    choices=["case", "planning_year", "model"],
    selected="model",
    width="150px",
)
ui.input_selectize(
    "emiss_col_var",
    "Column",
    choices=["case", "planning_year", "model", "None"],
    selected="case",
    width="150px",
)
ui.input_selectize(
    "emiss_row_var",
    "Row",
    choices=["case", "planning_year", "model", "None"],
    selected="planning_year",
    width="150px",
)
ui.input_selectize(
    "emiss_color",
    "Color",
    choices=["case", "planning_year", "model", "Region", "None"],
    selected="Region",
    width="150px",
)
```
```{python}
@render_altair
def emissions_chart():
    chart = chart_emissions(
        emiss_cases(),
        x_var=input.emiss_x_var(),
        col_var=input.emiss_col_var(),
        row_var=input.emiss_row_var(),
        color=input.emiss_color(),
        order=None,
    )
    return chart
```

# Operational results
## Row
#### Column {.tabset}
```{python}
# | content: card-toolbar
ui.input_selectize(
    "cost_x_var",
    "X Variable",
    choices=["case", "planning_year", "model"],
    selected="model",
    width="150px",
)
ui.input_selectize(
    "cost_col_var",
    "Column",
    choices=["case", "planning_year", "model", "None"],
    selected="case",
    width="150px",
)
ui.input_selectize(
    "cost_row_var",
    "Row",
    choices=["case", "planning_year", "model", "None"],
    selected="planning_year",
    width="150px",
)
```
```{python}
# | title: Model operational costs
@render_altair
def op_costs_model_chart():
    chart = chart_op_cost(
        op_costs_model_data(),
        col_var=input.cost_col_var(),
        x_var=input.cost_x_var(),
        row_var=input.cost_row_var(),
        order=None,
    )
    return chart
```
```{python}
# | title: Sociatal operational costs
@render_altair
def op_costs_chart():
    chart = chart_op_cost(
        op_costs_data(), col_var=input.cost_col_var(), x_var=input.cost_x_var(), row_var=input.cost_row_var(), order=None
    )
    return chart
```
```{python}
# | title: Operational NSE
@render_altair
def op_nse_chart():
    chart = chart_op_nse(
        op_nse_data(),
        col_var=input.cost_col_var(),
        x_var=input.cost_x_var(),
        row_var=input.cost_row_var(),
        order=None,
    )
    return chart
```    
```{python}
# | title: Op cost model data
@render.data_frame
def costs_model_df():
    return render.DataTable(op_costs_model_data().head(100))

```
```{python}
# | title: Op cost data
@render.data_frame
def costs_df():
    return render.DataTable(op_costs_data().head(100))

```
```{python}
# | title: Op NSE data
@render.data_frame
def nse_df():
    return render.DataTable(op_nse_data().head(100))

```



```{python}
def str_none(value):
    if value.lower() == "none":
        return None
    else:
        return value


VAR_ABBR_TITLE_MAP = {v: title_case(k) for k, v in VAR_ABBR_MAP.items()}
# VAR_ABBR_TITLE_MAP["v"] = "Capacity (GW)"
# VAR_ABBR_TITLE_MAP["v"] = "Generation (TWh)"


def var_to_none(var):
    if var == "None":
        return None
    return var


def chart_total_cap(
    cap: pd.DataFrame,
    mark_type: str = "bar",
    x_var="model",
    col_var=None,
    row_var="planning_year",
    color="tech_type",
    order=None,
    width=alt.Step(40),
    height=200,
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    group_by = []
    _tooltips = [
        alt.Tooltip(VAR_ABBR_MAP["end_value"], title="Capacity (GW)", format=",.0f"),
    ]

    for var in [x_var, col_var, row_var, color]:
        if var is not None:
            group_by.append(var)
            _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[var], title=title_case(var)))

    group_by = [c for c in set(group_by) if c in cap.columns]
    cap_data = cap.groupby(group_by, as_index=False)["end_value"].sum()
    cap_data["end_value"] /= 1000
    cap_data = cap_data.rename(columns=VAR_ABBR_MAP)
    if mark_type.lower() == "bar":
        c = alt.Chart(cap_data).mark_bar()
    else:
        c = alt.Chart(cap_data).mark_line()

    if color == "tech_type":
        _color = (
            alt.Color(VAR_ABBR_MAP[color])
            .scale(domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values()))
            .title(title_case(color))
        )
    else:
        _color = alt.Color(VAR_ABBR_MAP[color]).title(title_case(color))
    chart = c.encode(
        # x=alt.X(VAR_ABBR_MAP[x_var]).sort(order).title(title_case(x_var)),
        x=alt.X(VAR_ABBR_MAP[x_var])
        .sort(order_dict().get(x_var))
        .title(title_case(x_var)),
        y=alt.Y("sum(ev)").title("Capacity (GW)"),
        color=_color,
        tooltip=_tooltips,
    ).properties(width=width, height=height)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            # .sort(order)
            .title(title_case(row_var)).header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.encode(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.encode(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_total_cap_line(
    cap: pd.DataFrame,
    mark_type: str = "bar",
    x_var="planning_year",
    col_var="tech_type",
    row_var="case",
    color="model",
    order=None,
    scale="linear",
    width=alt.Step(40),
    height=200,
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    group_by = []
    _tooltips = [
        alt.Tooltip(VAR_ABBR_MAP["end_value"], title="Capacity (GW)", format=",.0f"),
    ]

    for var in [x_var, col_var, row_var, color]:
        if var is not None:
            group_by.append(var)
            _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[var], title=title_case(var)))

    group_by = [c for c in set(group_by) if c in cap.columns]
    cap_data = cap.groupby(group_by, as_index=False)["end_value"].sum()
    cap_data["end_value"] /= 1000
    cap_data = cap_data.rename(columns=VAR_ABBR_MAP)
    if mark_type.lower() == "bar":
        c = alt.Chart(cap_data).mark_bar()
    else:
        c = alt.Chart(cap_data).mark_line()

    if color == "tech_type":
        _color = (
            alt.Color(VAR_ABBR_MAP[color])
            .scale(domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values()))
            .title(title_case(color))
        )
    else:
        _color = alt.Color(VAR_ABBR_MAP[color]).title(title_case(color))
    chart = c.encode(
        x=alt.X(VAR_ABBR_MAP[x_var]).sort(order).title(title_case(x_var)),
        # x=alt.X("y")
        # .sort(order_dict().get("planning_year"))
        # .title(title_case("planning_year")),
        y=alt.Y("sum(ev)").title("Capacity (GW)").scale(type=scale.lower()),
        color=_color,
        tooltip=_tooltips,
        # column="tt",
        # row="c",
    ).properties(width=width, height=height)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            # .sort(order)
            .title(title_case(row_var)).header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.encode(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.encode(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_avg_new_tech_variation(
    annual_new_cap_mean: pd.DataFrame,
    x_var: str = "tech_type",
    col_var: str = "case",
    row_var: str = None,
    order=None,
    xOffset: str = None,
    bars_only=False,
    height=200,
    width=alt.Step(40),
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    data = annual_new_cap_mean.reset_index()
    for col in ["end_value", "min", "max"]:
        data[col] = (data[col] / 1000).round(1)

    if "agg_zone" not in [x_var, col_var, row_var]:
        data = data.groupby(
            [var for var in [x_var, col_var, row_var, "planning_year"] if var != None],
            as_index=False,
        ).sum()
    tooltips = [
        alt.Tooltip("y", title="Planning Year"),
        alt.Tooltip("ev", title="Capacity (GW)", format=",.0f"),
    ]
    if x_var and x_var != "None":
        tooltips.append(alt.Tooltip(VAR_ABBR_MAP[x_var], title=title_case(x_var)))
    if col_var and col_var != "None":
        tooltips.append(alt.Tooltip(VAR_ABBR_MAP[col_var], title=title_case(col_var)))
    if row_var and row_var != "None":
        tooltips.append(alt.Tooltip(VAR_ABBR_MAP[row_var], title=title_case(row_var)))
    # if bars_only:
    #     return bars

    bars = (
        alt.Chart()
        .mark_bar()
        .encode(
            y=alt.Y("sum(ev)").title("Capacity (GW)"),
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            color=alt.Color("tt")
            .scale(domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values()))
            .title(title_case("tech_type")),
            opacity=alt.Opacity("y:O", sort="descending").title(
                title_case("planning_year")
            ),
            order=alt.Order(
                # Sort the segments of the bars by this field
                "y",
                sort="ascending",
            ),
            tooltip=tooltips,
            # xOffset=alt.XOffset(VAR_ABBR_MAP.get(xOffset)),
        )
    )
    if xOffset:
        bars.encode(
            xOffset=alt.XOffset(VAR_ABBR_MAP.get(xOffset)),
        )

    error_bars = (
        alt.Chart()
        .mark_errorbar()
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var]).sort(order).title(title_case(x_var)),
            y=alt.Y("sum(max)").title("Capacity (GW)"),
            y2=alt.Y2("sum(min)"),
        )
        .properties(width=width, height=height)
    )
    data = data.rename(columns=VAR_ABBR_MAP)
    # data["o"] = data["tt"].map(TECH_STACK_ORDER)
    chart = alt.layer(bars, error_bars, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            # .sort(order)
            .title(title_case(row_var)).header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_total_gen(
    gen: pd.DataFrame,
    cap: pd.DataFrame = None,
    demand: pd.DataFrame = None,
    x_var="model",
    col_var=None,
    row_var="planning_year",
    order=None,
    width=alt.Step(40),
    height=200,
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    if gen.empty:
        return None
    merge_by = ["tech_type", "resource_name", x_var, "planning_year"]
    group_by = ["tech_type", x_var, "planning_year"]
    _tooltips = [
        alt.Tooltip("tt", title="Technology"),
        alt.Tooltip("v", title="Generation (TWh)", format=",.0f"),
    ]
    # if "new_build" in gen.columns:
    #     merge_by.append("new_build")
    #     group_by.append("new_build")
    #     _tooltips.append(alt.Tooltip("new_build", title="New Build"))
    if col_var is not None:
        group_by.append(col_var)
        merge_by.append(col_var)
        _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[col_var]).title(title_case(col_var)))
    if row_var is not None:
        _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[row_var]).title(title_case(row_var)))
        merge_by.append(row_var)
        group_by.append(row_var)
    merge_by = list(set(merge_by))
    group_by = list(set(group_by))
    if cap is not None:
        _cap = (
            cap.query("unit=='MW'")
            .groupby(
                merge_by,
                # ["tech_type", "resource_name", "model", "planning_year"],
                as_index=False,
            )["end_value"]
            .sum()
        )
        _gen = pd.merge(
            gen,
            _cap,
            # on=["tech_type", "resource_name", "model", "planning_year"],
            on=merge_by,
            how="left",
        )
        _gen.fillna({"end_value": 0}, inplace=True)
        _gen["potential_gen"] = _gen["end_value"] * 8760

        data = _gen.groupby(group_by, as_index=False)[
            ["value", "potential_gen", "end_value"]
        ].sum()
        data["capacity_factor"] = (data["value"] / data["potential_gen"]).round(3)
        _tooltips.extend(
            [
                alt.Tooltip("capacity_factor", title="Capacity Factor"),
                alt.Tooltip("ev", title="Capacity (MW)", format=",.0f"),
            ]
        )

    else:
        data = gen.groupby(group_by, as_index=False)["value"].sum()

    if demand is not None:
        # demand.loc[:, "agg_zone"] = demand.loc[:, "zone"].map(rev_region_map)
        data = pd.merge(
            data,
            demand.groupby(["planning_year"], as_index=False)["annual_demand"].sum(),
            on=["planning_year"],
        )
        data["annual_demand"] /= 1000000
    # else:
    #     demand = None
    data["value"] /= 1000000
    data = data.rename(columns=VAR_ABBR_MAP)
    data["o"] = data["tt"].map(TECH_STACK_ORDER)
    chart = (
        alt.Chart()  # data)
        .mark_bar()
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("v").title("Generation (TWh)"),
            color=alt.Color("tt").scale(
                domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values())
            )
            # .scale(scheme="tableau20")
            .title(title_case("tech_type")),
            # column="zone",
            # row="planning_year:O",
            tooltip=_tooltips,
            order="o",
        )
        .properties(width=width, height=height)
    )
    if demand is not None:
        line = (
            alt.Chart()
            .mark_rule()
            .encode(y=alt.Y("annual_demand"), tooltip="annual_demand")
        )
        chart = alt.layer(chart, line, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )

    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_total_gen_line(
    gen: pd.DataFrame,
    cap: pd.DataFrame = None,
    demand: pd.DataFrame = None,
    x_var="planning_year",
    col_var="tech_type",
    row_var="case",
    color="model",
    order=None,
    width=125,
    height=200,
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    group_by = []
    merge_by = ["resource_name"]
    _tooltips = [
        alt.Tooltip(VAR_ABBR_MAP["end_value"], title="Capacity (GW)", format=",.0f"),
    ]

    for var in [x_var, col_var, row_var, color]:
        if var is not None:
            group_by.append(var)
            merge_by.append(var)
            _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[var], title=title_case(var)))

    if gen.empty:
        return None
    # merge_by = ["tech_type", "resource_name", x_var, "planning_year"]
    # group_by = ["tech_type", x_var, "planning_year"]
    # _tooltips = [
    #     alt.Tooltip("tt", title="Technology"),
    #     alt.Tooltip("v", title="Generation (TWh)", format=",.0f"),
    # ]
    # # if "new_build" in gen.columns:
    # #     merge_by.append("new_build")
    # #     group_by.append("new_build")
    # #     _tooltips.append(alt.Tooltip("new_build", title="New Build"))
    # if col_var is not None:
    #     group_by.append(col_var)
    #     merge_by.append(col_var)
    #     _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[col_var]).title(title_case(col_var)))
    # if row_var is not None:
    #     _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[row_var]).title(title_case(row_var)))
    #     merge_by.append(row_var)
    #     group_by.append(row_var)
    merge_by = list(set(merge_by))
    group_by = list(set(group_by))
    if cap is not None:
        _cap = (
            cap.query("unit=='MW'")
            .groupby(
                merge_by,
                # ["tech_type", "resource_name", "model", "planning_year"],
                as_index=False,
            )["end_value"]
            .sum()
        )
        _gen = pd.merge(
            gen,
            _cap,
            # on=["tech_type", "resource_name", "model", "planning_year"],
            on=merge_by,
            how="left",
        )
        _gen.fillna({"end_value": 0}, inplace=True)
        _gen["potential_gen"] = _gen["end_value"] * 8760

        data = _gen.groupby(group_by, as_index=False)[
            ["value", "potential_gen", "end_value"]
        ].sum()
        data["capacity_factor"] = (data["value"] / data["potential_gen"]).round(3)
        _tooltips.extend(
            [
                alt.Tooltip("capacity_factor", title="Capacity Factor"),
                alt.Tooltip("ev", title="Capacity (MW)", format=",.0f"),
            ]
        )

    else:
        data = gen.groupby(group_by, as_index=False)["value"].sum()

    if demand is not None:
        # demand.loc[:, "agg_zone"] = demand.loc[:, "zone"].map(rev_region_map)
        data = pd.merge(
            data,
            demand.groupby(["planning_year"], as_index=False)["annual_demand"].sum(),
            on=["planning_year"],
        )
        data["annual_demand"] /= 1000000
    # else:
    #     demand = None
    data["value"] /= 1000000
    data = data.rename(columns=VAR_ABBR_MAP)
    data["o"] = data["tt"].map(TECH_STACK_ORDER)
    if color == "tech_type":
        _color = (
            alt.Color(VAR_ABBR_MAP[color])
            .scale(domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values()))
            .title(title_case(color))
        )
    else:
        _color = alt.Color(VAR_ABBR_MAP[color]).title(title_case(color))
    chart = (
        alt.Chart(data)
        .mark_line()
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("v").title("Generation (TWh)"),
            color=_color,
            # .scale(scheme="tableau20")
            # .title(title_case("tech_type")),
            # column="zone",
            # row="planning_year:O",
            tooltip=_tooltips,
            # order="o",
        )
        .properties(width=width, height=height)
    )
    # if demand is not None:
    #     line = (
    #         alt.Chart()
    #         .mark_rule()
    #         .encode(y=alt.Y("annual_demand"), tooltip="annual_demand")
    #     )
    #     chart = alt.layer(chart, line, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )

    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_avg_gen_variation(
    annual_gen_mean: pd.DataFrame,
    x_var: str = "tech_type",
    col_var: str = "case",
    row_var: str = None,
    xOffset: str = "planning_year",
    color: str = "tech_type",
    order=None,
    bars_only=False,
    height=200,
    width=alt.Step(60),
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)

    data = annual_gen_mean.reset_index()
    for col in ["value", "min", "max"]:
        data[col] = (data[col] / 1000000).round(0)
    tooltips = [
        alt.Tooltip("y", title="Planning Year"),
        alt.Tooltip("v", title="Generation (TWh)", format=",.0f"),
    ]
    if "agg_zone" not in [x_var, col_var, row_var]:
        data = data.groupby(
            [var for var in [x_var, col_var, row_var, "planning_year"] if var != None],
            as_index=False,
        ).sum()
    if x_var and not x_var == "None":
        tooltips.append(alt.Tooltip(VAR_ABBR_MAP.get(x_var), title=title_case(x_var)))
    if col_var and not col_var == "None":
        tooltips.append(
            alt.Tooltip(VAR_ABBR_MAP.get(col_var), title=title_case(col_var))
        )
    if row_var and not row_var == "None":
        tooltips.append(
            alt.Tooltip(VAR_ABBR_MAP.get(row_var), title=title_case(row_var))
        )
    # if bars_only:
    #     return bars
    if color == "tech_type":
        _color = (
            alt.Color("tt")
            .scale(domain=list(COLOR_MAP.keys()), range=list(COLOR_MAP.values()))
            .title(title_case("tech_type"))
        )
    else:
        _color = alt.Color(VAR_ABBR_MAP.get(color)).title(title_case(color))
    if xOffset is None:
        bars = (
            alt.Chart()
            .mark_bar()
            .encode(
                y=alt.Y("sum(v)").title("Generation (TWh)"),
                x=alt.X(VAR_ABBR_MAP[x_var])
                .sort(order_dict().get(x_var))
                .title(title_case(x_var)),
                color=_color,
                tooltip=tooltips,
            )
            .properties(width=width, height=height)
        )

        error_bars = (
            alt.Chart()
            .mark_errorbar()
            .encode(
                x=alt.X(VAR_ABBR_MAP[x_var])
                .sort(order_dict().get(x_var))
                .title(title_case(x_var)),
                y=alt.Y("sum(max)").title("Generation (TWh)"),
                y2=alt.Y2("sum(min)"),
            )
            .properties(width=width, height=height)
        )

    else:
        bars = (
            alt.Chart()
            .mark_bar(width=10)
            .encode(
                y=alt.Y("sum(v)").title("Generation (TWh)"),
                x=alt.X(VAR_ABBR_MAP[x_var])
                .sort(order_dict().get(x_var))
                .title(title_case(x_var)),
                color=_color,
                tooltip=tooltips,
                xOffset=alt.XOffset(VAR_ABBR_MAP.get(xOffset)).title(
                    title_case(xOffset)
                ),
                opacity=alt.Opacity(VAR_ABBR_MAP.get(xOffset)).title(
                    title_case(xOffset)
                ),
            )
            .properties(width=width, height=height)
        )

        error_bars = (
            alt.Chart()
            .mark_errorbar()
            .encode(
                x=alt.X(VAR_ABBR_MAP[x_var])
                .sort(order_dict().get(x_var))
                .title(title_case(x_var)),
                y=alt.Y("sum(max)").title("Generation (TWh)"),
                y2=alt.Y2("sum(min)"),
                xOffset=alt.XOffset(VAR_ABBR_MAP.get(xOffset)).title(
                    title_case(xOffset)
                ),
            )
            .properties(width=width, height=height)
        )
    data = data.rename(columns=VAR_ABBR_MAP)
    chart = alt.layer(bars, error_bars, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart

```

```{python}
@reactive.calc
def calc_mean_annual_cap(
    # cap: pd.DataFrame,
    # by_region: bool = False,
    # by_agg_zone: bool = False,
    # new_build: bool = True,
    # existing: bool = False,
    # value_col: str = "end_value",
) -> pd.DataFrame:
    by_region: bool = False
    by_agg_zone: bool = True
    new_build: bool = True
    existing: bool = False
    value_col: str = "end_value"
    cap = cap_cases()
    idx = pd.IndexSlice
    years = sorted(cap.planning_year.unique(), reverse=True)
    by = ["case", "tech_type", "planning_year"]
    if by_region:
        by.append("zone")
    if by_agg_zone:
        by.append("agg_zone")
    if new_build:
        _cap = cap.query("new_build == True and unit == 'MW'")
    elif existing:
        _cap = cap.query("new_build == False and unit == 'MW'")
    elif "unit" in cap.columns:
        _cap = cap.query("unit == 'MW'")
    else:
        _cap = cap.copy()
    idx_cols = ["case", "tech_type"]
    if by_region:
        idx_cols.append("zone")
    if by_agg_zone:
        idx_cols.append("agg_zone")

    df_list = []

    # Need to make sure that all techs are in all regions for cases submitted by each
    # model. Reindexing across all models screws up the min/max error bars when a model
    # has not submitted a case because the minimum becomes 0.
    for model in cap.model.unique():
        _model_cap = _cap.query("model==@model")
        midx = pd.MultiIndex.from_product(
            [_model_cap[c].unique() for c in by], names=by
        )
        _annual_cap = (
            _model_cap.query("model==@model")
            .groupby(by)[value_col]
            .sum()
            .reindex(midx)  # , fill_value=0)
            .reset_index()
            .set_index(idx_cols)
        )
        _annual_cap["model"] = model
        df_list.append(_annual_cap)
    annual_cap = pd.concat(df_list)
    if not new_build and not by_agg_zone:
        return (
            annual_cap.reset_index()
            .groupby(["case", "planning_year", "tech_type"], as_index=False)[value_col]
            .mean()
            .round({"end_value": 1})
        )
    elif not new_build and by_agg_zone:
        return (
            annual_cap.reset_index()
            .groupby(
                ["case", "planning_year", "tech_type", "agg_zone"], as_index=False
            )[value_col]
            .mean()
            .round({"end_value": 1})
        )
    for year, prev_year in zip(years[:-1], years[1:]):
        annual_cap.loc[annual_cap["planning_year"] == year, value_col] = annual_cap.loc[
            annual_cap["planning_year"] == year, value_col
        ].sub(
            annual_cap.loc[annual_cap["planning_year"] == prev_year, value_col],
            fill_value=0,
        )

    by = ["case", "tech_type", "planning_year"]
    if by_region:
        by.append("zone")
    if by_agg_zone:
        by.append("agg_zone")
    annual_cap_mean = pd.DataFrame(annual_cap.groupby(by)[value_col].mean())

    by = ["case", "tech_type", "model"]
    min_max_by = ["case", "tech_type"]
    if by_region:
        by.append("zone")
        min_max_by.append("zone")
    if by_agg_zone:
        by.append("agg_zone")
        min_max_by.append("agg_zone")
    annual_cap_mean.loc[idx[:, :, 2050], "min"] = (
        annual_cap.groupby(by)[value_col].sum().groupby(min_max_by).min().values
    )
    annual_cap_mean.loc[idx[:, :, 2050], "max"] = (
        annual_cap.groupby(by)[value_col].sum().groupby(min_max_by).max().values
    )
    return annual_cap_mean.round(1).reset_index()


@reactive.calc
def calc_mean_annual_gen(
    # gen: pd.DataFrame,
    # by_region: bool = False,
    # by_agg_zone: bool = False,
    # new_build: bool = False,
    # value_col: str = "value",
) -> pd.DataFrame:
    by_region: bool = False
    by_agg_zone: bool = True
    new_build: bool = False
    value_col: str = "value"
    gen = gen_cases()
    idx = pd.IndexSlice
    years = sorted(gen.planning_year.unique(), reverse=True)
    by = ["case", "tech_type", "planning_year"]
    if by_region:
        by.append("zone")
    if by_agg_zone:
        by.append("agg_zone")
    if new_build:
        _gen = gen.query("new_build == True")
    else:
        _gen = gen.copy()
    idx_cols = ["case", "tech_type"]
    if by_region:
        idx_cols.append("zone")
    if by_agg_zone:
        idx_cols.append("agg_zone")
    df_list = []

    # Need to make sure that all techs are in all regions for cases submitted by each
    # model. Reindexing across all models screws up the min/max error bars when a model
    # has not submitted a case because the minimum becomes 0.
    for model in gen.model.unique():
        _model_gen = _gen.query("model==@model")
        midx = pd.MultiIndex.from_product(
            [_model_gen[c].unique() for c in by], names=by
        )
        _annual_cap = (
            _model_gen.query("model==@model")
            .groupby(by)[value_col]
            .sum()
            .reindex(midx)  # , fill_value=0)
            .reset_index()
            .set_index(idx_cols)
        )
        _annual_cap["model"] = model
        df_list.append(_annual_cap)
    annual_gen = pd.concat(df_list)

    by = ["case", "tech_type", "planning_year"]
    if by_region:
        by.append("zone")
    if by_agg_zone:
        by.append("agg_zone")
    avg_gen = pd.DataFrame(
        annual_gen.reset_index()
        .groupby(by, as_index=False)[value_col]
        .agg(["mean", "min", "max"])
    ).rename(columns={"mean": "value"})
    return avg_gen


def single_op_cost_chart(
    data, x_var="model", col_var=None, row_var=None, order=None
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    _tooltip = [alt.Tooltip("Total", format=",.0f").title("Cost")]
    chart_cols = ["Costs", "Total", VAR_ABBR_MAP[x_var]]

    if "percent_total" in data.columns:
        _tooltip.append(alt.Tooltip("percent_total:Q", format=".1%").title("% Total"))
        chart_cols.append("percent_total")
    if col_var is not None:
        _tooltip.append(alt.Tooltip(VAR_ABBR_MAP[col_var]).title(title_case(col_var)))
        _tooltip.append(alt.Tooltip("Costs").title("Category"))
        chart_cols.append(VAR_ABBR_MAP[col_var])
    if row_var is not None:
        _tooltip.append(alt.Tooltip(VAR_ABBR_MAP[row_var]).title(title_case(row_var)))
        chart_cols.append(VAR_ABBR_MAP[row_var])
    data = data.rename(columns=VAR_ABBR_MAP)
    base = (
        alt.Chart()
        .mark_bar()
        .encode(
            # xOffset="model:N",
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("Total").title("Costs (Billion $)"),
            color=alt.Color("Costs:N").title("Category"),
            tooltip=_tooltip,
        )
    )

    text = (
        alt.Chart()
        .mark_text(dy=-5, fontSize=11)
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y="sum(Total):Q",
            text=alt.Text("sum(Total):Q", format=".0f"),
        )
    )

    chart = alt.layer(
        base,
        text,
        data=data[chart_cols].query("Total!=0 and Costs != 'cTotal'"),
    ).properties(width=alt.Step(40), height=200)

    if row_var is None and col_var is None:
        return chart
    elif row_var is None and col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif col_var is None and row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    else:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .title(title_case(row_var))
            .sort(order_dict().get(row_var))
            .header(titleFontSize=20, labelFontSize=15),
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .title(title_case(col_var))
            .sort(order_dict().get(col_var))
            .header(titleFontSize=20, labelFontSize=15),
        )

    return chart


def chart_op_cost(
    op_costs: pd.DataFrame, x_var="model", col_var=None, row_var=None, order=None
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    if op_costs.empty:
        return None
    if "NPV" in op_costs["planning_year"].unique():
        npv_costs = op_costs.loc[op_costs["planning_year"] == "NPV", :]
        op_costs = op_costs.loc[~(op_costs["planning_year"] == "NPV"), :]
    else:
        npv_costs = pd.DataFrame()
    if col_var is None and "planning_year" in op_costs.columns:
        col_var = "planning_year"

    data = op_costs.copy()
    data["Total"] /= 1e9
    data = data.rename(columns=VAR_ABBR_MAP)

    chart = single_op_cost_chart(data, x_var, col_var, row_var, order)
    if not npv_costs.empty:
        npv_data = npv_costs.copy()
        npv_data = npv_data.rename(columns=VAR_ABBR_MAP)
        npv_data["Total"] /= 1e9
        npv_chart = single_op_cost_chart(npv_data, x_var, col_var, row_var, order)
        if col_var == "planning_year":
            final_chart = chart | npv_chart
        elif row_var == "planning_year":
            final_chart = chart & npv_chart
        else:
            final_chart = chart
    final_chart = (
        final_chart.configure_axis(labelFontSize=15, titleFontSize=15)
        .configure_axis(labelFontSize=15, titleFontSize=15)
        .configure_legend(titleFontSize=20, labelFontSize=16)
    )
    return final_chart


def chart_emissions(
    emiss: pd.DataFrame,
    x_var="model",
    col_var=None,
    row_var=None,
    color="Region",
    order=None,
    co2_limit=True,
    height=200,
    width=alt.Step(40),
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    color = var_to_none(color)

    group_by = []
    _tooltips = [
        alt.Tooltip("sum(v)", format=",.0f", title="Million Tonnes"),
    ]

    for var in [x_var, col_var, row_var, color]:
        if var is not None:
            group_by.append(var)
            _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[var], title=title_case(var)))
    if emiss.empty:
        return None
    # _tooltips = [
    #     alt.Tooltip("sum(v)", format=",.0f", title="Million Tonnes"),
    #     alt.Tooltip("r", title="Region"),
    #     alt.Tooltip("m", title="Model"),
    #     alt.Tooltip("y", title="Planning Year"),
    # ]
    emiss["Region"] = emiss["zone"].map(rev_region_map)
    # group_by = ["Region", x_var, "planning_year"]
    # if col_var is not None:
    #     group_by.append(col_var)

    data = emiss.groupby(list(set(group_by)), as_index=False)["value"].sum()
    # if col_var is not None:
    #     _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[col_var]))
    if order is None:
        order = sorted(data[x_var].unique())
    data["value"] /= 1e6
    data["limit"] = 0.0
    data.loc[data["planning_year"] == 2027, "limit"] = 873.0
    data.loc[data["planning_year"] == 2030, "limit"] = 186.0
    data.loc[data["planning_year"] == 2035, "limit"] = 130.0
    data.loc[data["planning_year"] == 2040, "limit"] = 86.7
    data.loc[data["planning_year"] == 2045, "limit"] = 43.3
    data = data.rename(columns=VAR_ABBR_MAP)

    if color is None:
        _color = None
    else:
        _color = alt.Color(VAR_ABBR_MAP.get(color)).title(title_case(color))
    base = (
        alt.Chart()
        .mark_bar()
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("sum(v)").title("CO2 (Million Tonnes)"),
            color=_color,
            # alt.Color(VAR_ABBR_MAP.get(color)).title(
            #     title_case(color) or ""
            # ),  # .scale(scheme="tableau20"),
            # column="agg_zone",
            # row="planning_year:O",
            tooltip=_tooltips,
        )
        # .properties(width=350, height=250)
        # .resolve_scale(y="independent")
    )
    text = (
        alt.Chart()
        .mark_text(dy=-5)
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y="sum(v):Q",
            text=alt.Text("sum(v):Q", format=".0f"),
        )
        .properties(width=width, height=height)
    )  # .properties(width=350, height=250)
    if co2_limit and x_var == "model":
        size = 2
    else:
        size = 0
    line = (
        alt.Chart()
        .mark_rule(size=size)
        .encode(
            y=alt.Y("limit"),
        )  # column="agg_zone", row="planning_year")
        # .properties(width=150, height=250)
    )
    chart = alt.layer(base, text, line, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    # if col_var is None:
    #     chart = (
    #         alt.layer(base, text, line, data=data)
    #         # .properties(width=350, height=250)
    #         .facet(
    #             row=alt.Row("y:O")
    #             .title(title_case("planning_year"))
    #             .header(titleFontSize=20, labelFontSize=15)
    #         )
    #     )
    # else:
    #     chart = (
    #         alt.layer(base, text, line, data=data)
    #         # .properties(width=350, height=250)
    #         .facet(
    #             row=alt.Row("y:O")
    #             .title(title_case("planning_year"))
    #             .header(titleFontSize=20, labelFontSize=15),
    #             column=alt.Column(VAR_ABBR_MAP[col_var])
    #             .title(title_case(col_var))
    #             .header(titleFontSize=20, labelFontSize=15),
    #         )
    #     )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_emissions_line(
    emiss: pd.DataFrame,
    x_var="planning_year",
    col_var="case",
    row_var=None,
    color="model",
    order=None,
    height=200,
    width=125,
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    if emiss.empty:
        return None
    _tooltips = [
        alt.Tooltip("sum(v)", format=",.0f", title="Million Tonnes"),
        alt.Tooltip("r", title="Region"),
        alt.Tooltip("m", title="Model"),
        alt.Tooltip("y", title="Planning Year"),
    ]
    emiss["Region"] = emiss["zone"].map(rev_region_map)
    group_by = ["Region", x_var, "planning_year"]
    if col_var is not None:
        group_by.append(col_var)

    data = emiss.groupby(group_by, as_index=False)["value"].sum()
    if col_var is not None:
        _tooltips.append(alt.Tooltip(VAR_ABBR_MAP[col_var]))
    if order is None:
        order = sorted(data[x_var].unique())
    data["value"] /= 1e6
    data["limit"] = 0.0
    data.loc[data["planning_year"] == 2027, "limit"] = 873.0
    data.loc[data["planning_year"] == 2030, "limit"] = 186.0
    data.loc[data["planning_year"] == 2035, "limit"] = 130.0
    data.loc[data["planning_year"] == 2040, "limit"] = 86.7
    data.loc[data["planning_year"] == 2045, "limit"] = 43.3
    data = data.rename(columns=VAR_ABBR_MAP)
    base = (
        alt.Chart()
        .mark_bar()
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("sum(v)").title("CO2 (Million Tonnes)"),
            color=alt.Color("r").title("Region"),  # .scale(scheme="tableau20"),
            # column="agg_zone",
            # row="planning_year:O",
            tooltip=_tooltips,
        )
        # .properties(width=350, height=250)
        # .resolve_scale(y="independent")
    )
    text = (
        alt.Chart()
        .mark_text(dy=-5)
        .encode(
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y="sum(v):Q",
            text=alt.Text("sum(v):Q", format=".0f"),
        )
        .properties(width=width, height=height)
    )  # .properties(width=350, height=250)
    if co2_limit:
        size = 2
    else:
        size = 0
    line = (
        alt.Chart()
        .mark_rule(size=size)
        .encode(
            y=alt.Y("limit"),
        )  # column="agg_zone", row="planning_year")
        # .properties(width=150, height=250)
    )
    chart = alt.layer(base, text, line, data=data)
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.facet(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


def chart_tx_expansion(
    tx_data: pd.DataFrame,
    x_var="model",
    facet_col="line_name",
    n_cols=10,
    col_var=None,
    row_var=None,
    order=None,
    height=200,
    width=alt.Step(20),
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    if tx_data.empty:
        return None
    if tx_data[x_var].nunique() < 4:
        width = 80
    tx_data["line_name"] = tx_data["line_name"].str.replace("_to_", " | ")

    by = [
        c
        for c in [x_var, facet_col, col_var, row_var, "planning_year"]
        if c is not None
    ]
    data = tx_data.groupby(by, as_index=False)["value"].sum()

    _tooltip = [
        alt.Tooltip("sum(v)", format=",.0f", title="Period GW"),
        alt.Tooltip("y", title=title_case("planning_year")),
    ]

    if order is None:
        order = sorted(data[x_var].unique())
    if col_var is None or row_var is None:
        first_year = data["planning_year"].min()
        idx_cols = [c for c in [x_var, facet_col, col_var, row_var] if c is not None]
        data = data.set_index(idx_cols)
        first_data = data.query("planning_year == @first_year")
        df_list = []
        for year in data["planning_year"].unique():
            _df = data.query("planning_year == @year")
            if year == first_year:
                _df["line_growth"] = 0
                # df_list.append(_df)
            else:
                try:
                    _df["line_growth"] = (_df["value"] / first_data["value"]).fillna(0)
                except:
                    _df["line_growth"] = 0
            df_list.append(_df)
        data = pd.concat(df_list).reset_index()
        if not (col_var is None and row_var is None):
            _tooltip.append(alt.Tooltip("line_growth", format=".1%"))

    if x_var == "case":
        _tooltip.append(
            alt.Tooltip("c").title("Case"),
        )
    data["value"] /= 1000
    data = data.rename(columns=VAR_ABBR_MAP)
    chart = (
        alt.Chart(data)
        .mark_bar()
        .encode(
            # xOffset="model:N",
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("sum(v)").title("Transmission (GW)"),
            color=alt.Color("m:N").title(title_case("model")),
            opacity=alt.Opacity("y:O", sort="descending").title(
                title_case("planning_year")
            ),
            # facet=alt.Facet("line_name", columns=n_cols),
            order=alt.Order(
                # Sort the segments of the bars by this field
                "y",
                sort="ascending",
            ),
            tooltip=_tooltip,
        )
        .properties(
            height=height,
            width=width,
        )
    )
    if facet_col is not None:
        chart = chart.encode(
            facet=alt.Facet(VAR_ABBR_MAP[facet_col], columns=n_cols)
            .title(title_case(facet_col))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif col_var is None and row_var is None:
        text = (
            alt.Chart()
            .mark_text(dy=-5, fontSize=14)
            .encode(
                x=alt.X(VAR_ABBR_MAP[x_var])
                .sort(order_dict().get(x_var))
                .title(title_case(x_var)),
                y="sum(v):Q",
                text=alt.Text("sum(v):Q", format=".0f"),
            )
        )
        chart = alt.layer(chart, text, data=data).properties(width=width)
    if col_var is not None:
        chart = chart.encode(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    if row_var is not None:
        chart = chart.encode(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    if all([i is None for i in [facet_col, row_var, col_var]]):
        chart = (
            chart.properties(height=400, width=300)
            .configure_axis(labelFontSize=16, titleFontSize=18)
            .configure_legend(titleFontSize=20, labelFontSize=16)
        )
    return chart


def chart_tx_map(
    tx_exp: pd.DataFrame,
    gdf: gpd.GeoDataFrame,
    facet_col="model",
    colormap="magma",
    reverse_colors=True,
    min_total_expansion=1,
    **kwargs,
) -> alt.Chart:
    geoshape_kwargs = {
        "stroke": "white",
        "fill": "silver",
    }
    geoshape_kwargs.update(kwargs)
    tx_exp["lat1"] = tx_exp["start_region"].map(gdf.set_index("zone")["lat"])
    tx_exp["lon1"] = tx_exp["start_region"].map(gdf.set_index("zone")["lon"])
    tx_exp["lat2"] = tx_exp["dest_region"].map(gdf.set_index("zone")["lat"])
    tx_exp["lon2"] = tx_exp["dest_region"].map(gdf.set_index("zone")["lon"])

    model_figs = []
    data = tx_exp.copy()
    # data["value"] /= 1000
    for model, _data in tx_exp.groupby(facet_col):
        background = (
            alt.Chart(gdf, title=f"{model}")
            .mark_geoshape(**geoshape_kwargs)
            .project(type="albersUsa")
            .properties(height=325, width=400)
        )
        by = ["line_name", "lat1", "lat2", "lon1", "lon2", facet_col]
        _data = (
            _data.query("planning_year >= 2025")
            .groupby(by, as_index=False)["value"]
            .sum()
        )
        lines = (
            alt.Chart(_data.loc[_data["value"] >= min_total_expansion, :])
            .mark_rule()
            .encode(
                latitude="lat1",
                longitude="lon1",
                latitude2="lat2",
                longitude2="lon2",
                strokeWidth="sum(value)",
                color=alt.Color("sum(value):Q")
                .scale(scheme=colormap, reverse=reverse_colors)
                .title("Expansion (MW)"),
                tooltip=[
                    alt.Tooltip("line_name"),
                    alt.Tooltip("sum(value)", title="Expansion (MW)"),
                ],
            )
            .project(type="albersUsa")
        )

        model_figs.append(background + lines)
    num_cols = int(len(model_figs) / 2)
    chart = alt.vconcat(
        alt.hconcat(*model_figs[:num_cols]), alt.hconcat(*model_figs[num_cols:])
    ).configure_concat(spacing=-50)
    chart = (
        chart.configure_axis(labelFontSize=15, titleFontSize=15)
        .configure_legend(titleFontSize=20, labelFontSize=18)
        .configure_title(fontSize=20, dy=35)
    )
    return chart


def chart_op_nse(
    op_nse: pd.DataFrame, x_var="model", col_var=None, row_var=None, order=None
) -> alt.Chart:
    x_var = var_to_none(x_var)
    col_var = var_to_none(col_var)
    row_var = var_to_none(row_var)
    cols = ["Segment", "Total", "model"]
    if "planning_year" in op_nse and row_var != "planning_year":
        col_var = "planning_year"
    if col_var is not None:
        cols.append(col_var)
    if row_var is not None:
        cols.append(row_var)
    if op_nse.empty:
        return None
    data = op_nse.copy()
    data["value"] /= 1000
    data = data.rename(columns=VAR_ABBR_MAP)
    chart = (
        alt.Chart(data)
        .mark_bar()
        .encode(
            # xOffset="model:N",
            x=alt.X(VAR_ABBR_MAP[x_var])
            .sort(order_dict().get(x_var))
            .title(title_case(x_var)),
            y=alt.Y("sum(v)").title("Annual non-served GWh"),
            color=alt.Color("model:N").title(title_case("model")),
            tooltip=alt.Tooltip("sum(v)", format=",.0f", title="NSE"),
        )
        .properties(width=alt.Step(40), height=250)
    )
    if col_var is not None and row_var is not None:
        chart = chart.facet(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .sort(order_dict().get(col_var))
            .title(title_case(col_var))
            .header(titleFontSize=20, labelFontSize=15),
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .sort(order_dict().get(row_var))
            .title(title_case(row_var))
            .header(titleFontSize=20, labelFontSize=15),
        )
    elif col_var is not None:
        chart = chart.encode(
            column=alt.Column(VAR_ABBR_MAP[col_var])
            .title(title_case(col_var))
            .sort(order_dict().get(col_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    elif row_var is not None:
        chart = chart.encode(
            row=alt.Row(VAR_ABBR_MAP[row_var])
            .title(title_case(row_var))
            .sort(order_dict().get(row_var))
            .header(titleFontSize=20, labelFontSize=15)
        )
    chart = chart.configure_axis(labelFontSize=15, titleFontSize=15).configure_legend(
        titleFontSize=20, labelFontSize=16
    )
    return chart


```